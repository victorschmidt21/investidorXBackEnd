package com.java.Invista.service;

import com.java.Invista.entity.AddressEntity;
import com.java.Invista.entity.CityEntity;
import com.java.Invista.repository.RepositoryAddress;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("Testes do AddressService")
class AddressServiceTest {

    @Mock
    private RepositoryAddress repositoryAddress;

    @InjectMocks
    private AddressService addressService;

    private AddressEntity existingAddress;
    private AddressEntity updateData;
    private CityEntity city;

    @BeforeEach
    void setUp() {
        System.out.println("üèóÔ∏è Preparando dados de teste...");

        // CRIA CIDADE
        city = new CityEntity();
        city.setId(1L);
        city.setNome("S√£o Paulo");

        // CRIA ENDERE√áO EXISTENTE
        existingAddress = new AddressEntity();
        existingAddress.setId(1L);
        existingAddress.setStreet("Rua das Flores");
        existingAddress.setNumber(123);
        existingAddress.setNeighborhood("Centro");
        existingAddress.setCep(12345678);
        existingAddress.setCity(city);

        // CRIA DADOS PARA ATUALIZA√á√ÉO
        updateData = new AddressEntity();

        System.out.println("‚úÖ Dados preparados!");
    }

    @Test
    @DisplayName("Deve atualizar endere√ßo com todos os campos")
    void deveAtualizarEnderecoComTodosOsCampos() {
        System.out.println("‚úèÔ∏è Testando atualiza√ß√£o completa do endere√ßo...");

        // CONFIGURA DADOS DE ATUALIZA√á√ÉO
        CityEntity newCity = new CityEntity();
        newCity.setId(2L);
        newCity.setNome("Rio de Janeiro");

        updateData.setStreet("Avenida Paulista");
        updateData.setNumber(456);
        updateData.setNeighborhood("Bela Vista");
        updateData.setCep(87654321);
        updateData.setCity(newCity);

        // CONFIGURA MOCKS
        when(repositoryAddress.findById(1L)).thenReturn(Optional.of(existingAddress));
        when(repositoryAddress.save(any(AddressEntity.class))).thenReturn(existingAddress);

        // EXECUTA
        AddressEntity result = addressService.update(1L, updateData);

        // VERIFICA RESULTADO
        assertThat(result).isNotNull();
        assertThat(result.getStreet()).isEqualTo("Avenida Paulista");
        assertThat(result.getNumber()).isEqualTo(456);
        assertThat(result.getNeighborhood()).isEqualTo("Bela Vista");
        assertThat(result.getCity().getNome()).isEqualTo("Rio de Janeiro");

        // VERIFICA CHAMADAS
        verify(repositoryAddress, times(1)).findById(1L);
        verify(repositoryAddress, times(1)).save(any(AddressEntity.class));

        System.out.println("‚úÖ Atualiza√ß√£o completa funcionou!");
    }

    @Test
    @DisplayName("Deve atualizar apenas a rua")
    void deveAtualizarApenasARua() {
        System.out.println("üõ£Ô∏è Testando atualiza√ß√£o apenas da rua...");

        // CONFIGURA APENAS A RUA
        updateData.setStreet("Nova Rua");
        updateData.setNeighborhood(""); // String vazia - n√£o deve atualizar
        updateData.setNumber(null);     // Null - n√£o deve atualizar
        updateData.setCity(null);       // Null - n√£o deve atualizar

        // CONFIGURA MOCKS
        when(repositoryAddress.findById(1L)).thenReturn(Optional.of(existingAddress));
        when(repositoryAddress.save(any(AddressEntity.class))).thenReturn(existingAddress);

        // EXECUTA
        AddressEntity result = addressService.update(1L, updateData);

        // VERIFICA QUE APENAS A RUA FOI ATUALIZADA
        assertThat(result.getStreet()).isEqualTo("Nova Rua");
        assertThat(result.getNumber()).isEqualTo(123); // Valor original
        assertThat(result.getNeighborhood()).isEqualTo("Centro"); // Valor original
        assertThat(result.getCity().getNome()).isEqualTo("S√£o Paulo"); // Valor original

        verify(repositoryAddress, times(1)).findById(1L);
        verify(repositoryAddress, times(1)).save(any(AddressEntity.class));

        System.out.println("‚úÖ Atualiza√ß√£o parcial funcionou!");
    }

    @Test
    @DisplayName("Deve atualizar apenas o bairro")
    void deveAtualizarApenasOBairro() {
        System.out.println("üèòÔ∏è Testando atualiza√ß√£o apenas do bairro...");

        // CONFIGURA APENAS O BAIRRO
        updateData.setNeighborhood("Novo Bairro");
        updateData.setStreet(""); // String vazia - n√£o deve atualizar
        updateData.setNumber(null);
        updateData.setCity(null);

        // CONFIGURA MOCKS
        when(repositoryAddress.findById(1L)).thenReturn(Optional.of(existingAddress));
        when(repositoryAddress.save(any(AddressEntity.class))).thenReturn(existingAddress);

        // EXECUTA
        AddressEntity result = addressService.update(1L, updateData);

        // VERIFICA
        assertThat(result.getNeighborhood()).isEqualTo("Novo Bairro");
        assertThat(result.getStreet()).isEqualTo("Rua das Flores"); // Original
        assertThat(result.getNumber()).isEqualTo(123); // Original

        System.out.println("‚úÖ Atualiza√ß√£o do bairro funcionou!");
    }

    @Test
    @DisplayName("Deve atualizar apenas o n√∫mero")
    void deveAtualizarApenasONumero() {
        System.out.println("üî¢ Testando atualiza√ß√£o apenas do n√∫mero...");

        // CONFIGURA APENAS O N√öMERO
        updateData.setNumber(999);
        updateData.setStreet("");
        updateData.setNeighborhood("");
        updateData.setCity(null);

        // CONFIGURA MOCKS
        when(repositoryAddress.findById(1L)).thenReturn(Optional.of(existingAddress));
        when(repositoryAddress.save(any(AddressEntity.class))).thenReturn(existingAddress);

        // EXECUTA
        AddressEntity result = addressService.update(1L, updateData);

        // VERIFICA
        assertThat(result.getNumber()).isEqualTo(999);
        assertThat(result.getStreet()).isEqualTo("Rua das Flores"); // Original

        System.out.println("‚úÖ Atualiza√ß√£o do n√∫mero funcionou!");
    }

    @Test
    @DisplayName("Deve atualizar apenas a cidade")
    void deveAtualizarApenasACidade() {
        System.out.println("üèôÔ∏è Testando atualiza√ß√£o apenas da cidade...");

        // CONFIGURA APENAS A CIDADE
        CityEntity newCity = new CityEntity();
        newCity.setId(3L);
        newCity.setNome("Bras√≠lia");

        updateData.setCity(newCity);
        updateData.setStreet("");
        updateData.setNeighborhood("");
        updateData.setNumber(null);

        // CONFIGURA MOCKS
        when(repositoryAddress.findById(1L)).thenReturn(Optional.of(existingAddress));
        when(repositoryAddress.save(any(AddressEntity.class))).thenReturn(existingAddress);

        // EXECUTA
        AddressEntity result = addressService.update(1L, updateData);

        // VERIFICA
        assertThat(result.getCity().getNome()).isEqualTo("Bras√≠lia");
        assertThat(result.getStreet()).isEqualTo("Rua das Flores"); // Original

        System.out.println("‚úÖ Atualiza√ß√£o da cidade funcionou!");
    }

    @Test
    @DisplayName("N√£o deve atualizar com strings vazias")
    void naoDeveAtualizarComStringsVazias() {
        System.out.println("üö´ Testando que strings vazias n√£o atualizam...");

        // CONFIGURA STRINGS VAZIAS
        updateData.setStreet(""); // N√£o deve atualizar
        updateData.setNeighborhood(""); // N√£o deve atualizar
        updateData.setNumber(null); // N√£o deve atualizar
        updateData.setCity(null); // N√£o deve atualizar

        // CONFIGURA MOCKS
        when(repositoryAddress.findById(1L)).thenReturn(Optional.of(existingAddress));
        when(repositoryAddress.save(any(AddressEntity.class))).thenReturn(existingAddress);

        // EXECUTA
        AddressEntity result = addressService.update(1L, updateData);

        // VERIFICA QUE NADA FOI ALTERADO
        assertThat(result.getStreet()).isEqualTo("Rua das Flores"); // Original
        assertThat(result.getNeighborhood()).isEqualTo("Centro"); // Original
        assertThat(result.getNumber()).isEqualTo(123); // Original
        assertThat(result.getCity().getNome()).isEqualTo("S√£o Paulo"); // Original

        System.out.println("‚úÖ Strings vazias n√£o atualizaram!");
    }

    @Test
    @DisplayName("Deve lan√ßar exce√ß√£o quando endere√ßo n√£o existe para atualizar")
    void deveLancarExcecaoQuandoEnderecoNaoExisteParaAtualizar() {
        System.out.println("‚ùå Testando endere√ßo n√£o encontrado para atualiza√ß√£o...");

        // CONFIGURA MOCK PARA RETORNAR VAZIO
        when(repositoryAddress.findById(999L)).thenReturn(Optional.empty());

        // EXECUTA E VERIFICA EXCE√á√ÉO
        assertThatThrownBy(() -> addressService.update(999L, updateData))
            .isInstanceOf(RuntimeException.class); // O c√≥digo atual vai dar NoSuchElementException

        verify(repositoryAddress, times(1)).findById(999L);
        verify(repositoryAddress, never()).save(any(AddressEntity.class));

        System.out.println("‚úÖ Exce√ß√£o para endere√ßo n√£o encontrado funcionou!");
    }

    @Test
    @DisplayName("Deve deletar endere√ßo existente")
    void deveDeletarEnderecoExistente() {
        System.out.println("üóëÔ∏è Testando dele√ß√£o de endere√ßo existente...");

        // CONFIGURA MOCK
        when(repositoryAddress.findById(1L)).thenReturn(Optional.of(existingAddress));
        doNothing().when(repositoryAddress).deleteById(1L);

        // EXECUTA
        addressService.delete(1L);

        // VERIFICA CHAMADAS
        verify(repositoryAddress, times(1)).findById(1L);
        verify(repositoryAddress, times(1)).deleteById(1L);

        System.out.println("‚úÖ Dele√ß√£o funcionou!");
    }

    @Test
    @DisplayName("Deve lan√ßar exce√ß√£o ao deletar endere√ßo inexistente")
    void deveLancarExcecaoAoDeletarEnderecoInexistente() {
        System.out.println("‚ùå Testando dele√ß√£o de endere√ßo inexistente...");

        // CONFIGURA MOCK PARA RETORNAR VAZIO
        when(repositoryAddress.findById(999L)).thenReturn(Optional.empty());

        // EXECUTA E VERIFICA EXCE√á√ÉO
        assertThatThrownBy(() -> addressService.delete(999L))
            .isInstanceOf(RuntimeException.class)
            .hasMessage("Endere√ßo n√£o encontrado");

        // VERIFICA QUE DELETE N√ÉO FOI CHAMADO
        verify(repositoryAddress, times(1)).findById(999L);
        verify(repositoryAddress, never()).deleteById(anyLong());

        System.out.println("‚úÖ Exce√ß√£o para endere√ßo n√£o encontrado funcionou!");
    }

    @Test
    @DisplayName("Deve tratar caso onde o Optional est√° vazio na atualiza√ß√£o")
    void deveTratarCasoOndeOptionalEstaVazioNaAtualizacao() {
        System.out.println("‚ö†Ô∏è Testando comportamento com Optional vazio...");

        // CONFIGURA MOCK PARA RETORNAR VAZIO
        when(repositoryAddress.findById(1L)).thenReturn(Optional.empty());

        // EXECUTA E VERIFICA QUE LAN√áA EXCE√á√ÉO
        assertThatThrownBy(() -> addressService.update(1L, updateData))
            .isInstanceOf(RuntimeException.class); // Na verdade ser√° NoSuchElementException

        verify(repositoryAddress, times(1)).findById(1L);
        verify(repositoryAddress, never()).save(any(AddressEntity.class));

        System.out.println("‚úÖ Comportamento com Optional vazio OK!");
    }
}